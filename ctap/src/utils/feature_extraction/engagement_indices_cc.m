function [spect_data, spect_labels, Info] =...
    engagement_indices_cc(psd_fz, psd_pz, BandDef, varargin)
% ENGAGEMENT_INDICES_CC - Calculate indices that combine derivations Fz and Pz
%
% Description:
%   Calculates some spectral measures of engagement from given PSDs.
%
%   Does not contain runtime constants not defined by function arguments.
%
% Syntax:
%   [spect_data,spect_labels]= engagement_indices_cc(psd_fz, psd_pz, BandDef);
%
% Inputs:
%   psd_fz      [ncs, psdlen] double, PSD from channel Fz or equivalent location
%   psd_pz      [ncs, psdlen] double, PSD from channel Pz or equivalent location
%       Band powers should be as returned by eeg.psd.m. Normalization is
%       performed in this function as needed.
%   BandDef     struct, Defines frequency bands and other related measures
%       .fmin       [1,4] double, lower bounds in Hz
%       .fmax       [1,4] double, upper bounds in Hz
%       .freqRes    [1,1] double, Frequency resolution of the PSDs in Hz
%       .bandLabels [1,m] cell, Frequency band labels, at least bands
%                   {'theta', 'alpha'} have to be defined
%   varargin    Keyword-value pairs
%   Keyword             Type, description, values
%   'integrationMethod' string, Integration method to use when summing up
%                       band powers, default: "trapez"
%                       "trapez" = trapezoidal integration using trapz()
%                       "sum" = plain sum
%
% Outputs:
%  spect_data     [ncs,n] double, Engagement index data
%  spect_labels   [1,n] cell of strings, Engagement index names
%  Info           struct, Variable information for autogenerated
%                 documentation
%
% Notes: An earlier version of this function relied on frequency bands
% appearing in a particular order. This new version does not care about the
% order but requires certain bands to be present, labeled as shown above.
%
% Jussi Korpela, 22.12.2006, TTL     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Default parameter values
% Field names of 'Arg' can be used as keywords.
Arg.integrationMethod = 'trapez'; %'sum','trapez'

%% Interpret 'varargin'
% Overwrite default parameter values with user-defined ones
if ~isempty(varargin)
    Arg = input_interp(varargin, Arg);
end

%% Check inputs
if sum(strcmp(Arg.integrationMethod, {'trapez','sum'}))==0
    msg = ['Unknown integration method. Found ''', Arg.integrationMethod,...
           ''' but only ''trapez'' and ''sum'' allowed'];
    error('bandpowers:unknownVararginValue', msg);
    
end

if size(psd_fz,1)~=size(psd_pz,1)
    error('engagement_indices_cc:SpectrumDimensionError1'...
        , 'PSDs have to have equal number of rows!');
elseif  size(psd_fz,2)~=size(psd_pz,2)
    error('engagement_indices_cc:SpectrumDimensionError2'...
        , 'PSDs have to have equal number of columns!');
end

if length(BandDef.fmin) ~= length(BandDef.fmax),
    error('engagement_indices_cc:FrequencyVectorDimensionError'...
        , 'Frequency vectors must have equal lengths!');
end

%% Preallocate variables
lines_max = size(psd_fz,1);
columns_max = 4;
% Debug & testing:
%columns_max = 4+4*length(BandDef.fmin);
spect_data = NaN(lines_max, columns_max);

% Find out band indices in 'BandDef'
bandLabelsLower = cellfun(@lower, BandDef.bandLabels, 'UniformOutput',false);
kTheta = find(ismember(bandLabelsLower, 'theta'));
kAlpha = find(ismember(bandLabelsLower, 'alpha'));

if isempty(kTheta) || isempty(kAlpha)
    msg = ['Could not find match for ''theta'' or ''alpha'' among lower'...
        'cased band labels. Cannot compute.']; 
    error('engagement_indices_cc:inputError', msg);
end


%% Normalize PSD data
if strcmp(Arg.integrationMethod, 'sum')
    psd_fz_bp_tot = sum(psd_fz, 2); 
    psd_pz_bp_tot = sum(psd_pz, 2); 
else
    psd_fz_bp_tot = trapz(psd_fz, 2); 
    psd_pz_bp_tot = trapz(psd_pz, 2); 
end  
psd_fz_rel = psd_fz ./ repmat(psd_fz_bp_tot, 1, size(psd_fz,2));
psd_pz_rel = psd_pz ./ repmat(psd_pz_bp_tot, 1, size(psd_pz,2));


%% Calculate band powers and engagement indices
% Note that no scaling factors are used, because in the BB division those
% will cancel each other out.
% Tested that this code produces the same band powers as bandpowers.m.
for i=1:lines_max %through calculation segments
    
    i_band_powers_fz = NaN(1,length(BandDef.fmax));
    i_band_powers_pz = NaN(1,length(BandDef.fmax));
    for k = 1:length(BandDef.fmax)
        i_min = round(BandDef.fmin(k)/BandDef.freqRes);
        i_max = round(BandDef.fmax(k)/BandDef.freqRes);
        
        if strcmp(Arg.integrationMethod, 'sum')
            i_band_powers_fz(k) = sum(psd_fz(i, i_min:i_max));
            i_band_powers_pz(k) = sum(psd_pz(i, i_min:i_max));
            %%%%%%%%%%%%%%%%%%%%
            i_band_powers_fz_rel(k) = sum(psd_fz_rel(i, i_min:i_max));
            i_band_powers_pz_rel(k) = sum(psd_pz_rel(i, i_min:i_max));
        else
            i_band_powers_fz(k) = trapz(psd_fz(i, i_min:i_max),2);
            i_band_powers_pz(k) = trapz(psd_pz(i, i_min:i_max),2);
            %%%%%%%%%%%%%%%%%%%%%
            i_band_powers_fz_rel(k) = trapz(psd_fz_rel(i, i_min:i_max),2);
            i_band_powers_pz_rel(k) = trapz(psd_pz_rel(i, i_min:i_max),2);
        end
       
    end
    
    %EDIT WHEN ADDING/REMOWING VARIABLES
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % The original brain beat
    spect_data(i,1)= i_band_powers_fz(kTheta)/i_band_powers_pz(kAlpha); %BB
    spect_data(i,2)= i_band_powers_fz(kTheta)/i_band_powers_fz(kAlpha); %FzBB
    %%%%%%%%%%%%%%%%%%%%%%%%%%
    % Brain beat using relative band powers
    spect_data(i, 3) =...
        i_band_powers_fz_rel(kTheta) / i_band_powers_pz_rel(kAlpha); %p_ind
    spect_data(i, 4) =...
        i_band_powers_fz_rel(kTheta) / i_band_powers_fz_rel(kAlpha); %f_ind
    
    % Debug and testing:
    %{
    i_bp_mat = horzcat(i_band_powers_fz, i_band_powers_pz,...
                            i_band_powers_fz_rel, i_band_powers_pz_rel);
    spect_data(i,5:end) = i_bp_mat;
    %}
    clear('i_*');
end

%EDIT WHEN ADDING/REMOWING VARIABLES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
spect_labels(1)= {'BB'};%fromer pInd
spect_labels(2)= {'FzBB'};%former fInd
spect_labels(3)= {'BB_rel'};%fromer pInd
spect_labels(4)= {'FzBB_rel'};%former fInd

% Debug and testing:
%{
spect_labels = horzcat(spect_labels,...
    strcat('Fz_',BandDef.bandLabels, '_abs'),...
    strcat('Pz_',BandDef.bandLabels, '_abs'),...
    strcat('Fz_',BandDef.bandLabels, '_rel'),...
    strcat('Pz_',BandDef.bandLabels, '_rel'));
%}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Initialize Info
Info.Variable = spect_labels;
Info.Type = cell(1,length(spect_labels));
Info.Unit = cell(1,length(spect_labels));
Info.Values = cell(1,length(spect_labels));

% Assign data to Info
Info.Type(:) = {'numeric'};
Info.Unit(1:2) = {'dimensionless'};
Info.Unit(3:end) = {'power'};
Info.Values(:) = {'NA'};

Info.Description(1) = {'EEG PSD engagement index: BB: fz_theta/pz_alpha'};
Info.Description(2) = {'EEG PSD engagement index: FzBB: fz_theta/fz_alpha'};
Info.Description(3) = {'EEG PSD engagement index: BB_rel: fz_theta/pz_alpha (rel)'};
Info.Description(4) = {'EEG PSD engagement index: FzBB_rel: fz_theta/fz_alpha (rel)'};

% Debug and testing:
%{
fmin_cstr = cellfun(@num2str, num2cell(BandDef.fmin), 'uniformOutput', false);
fmax_cstr = cellfun(@num2str, num2cell(BandDef.fmax), 'uniformOutput', false);
desc1=strcat('EEG spectral band power, absolute, channel Fz, band: ',fmin_cstr,'-',fmax_cstr,' Hz.');
desc2=strcat('EEG spectral band power, absolute, channel Pz, band: ',fmin_cstr,'-',fmax_cstr,' Hz.');
desc3=strcat('EEG spectral band power, relative, channel Fz, band: ',fmin_cstr,'-',fmax_cstr,' Hz.');
desc4=strcat('EEG spectral band power, relative, channel Pz, band: ',fmin_cstr,'-',fmax_cstr,' Hz.');
Info.Description = horzcat(Info.Description, desc1, desc2, desc3, desc4);
%}